# Система умного дома и интернет‑магазина (финальное задание 19-22 спринтов)


Проект объединяет **два крупных функциональных блока**:
1. Сервисы для работы с телеметрией умного дома (`Collector`, `Aggregator`, `Analyzer`).
2. Микросервисы интернет‑магазина (`shopping-store`, `shopping-cart`, `warehouse`, `order`, `payment`, `delivery`).

---

## Блок 1. Сервисы телеметрии умного дома


### 1. Сервис Collector


**Назначение**: приём, валидация и маршрутизация телеметрических данных от хабов умного дома.

**Ключевые функции**:
* приём HTTP‑запросов (JSON) через эндпоинты `/sensors` и `/hubs`;
* валидация данных по спецификации OpenAPI;
* десериализация JSON в Java‑объекты с учётом типа события (`type`);
* преобразование в формат Avro;
* отправка в топики Kafka.

**Топики Kafka**:
* `telemetry.sensors.v1` — данные от датчиков;
* `telemetry.hubs.v1` — события хаба и сценариев.

**Схемы Avro** (пространство имён: `ru.yandex.practicum.kafka.telemetry.event`):
* для датчиков: `ClimateSensorAvro`, `LightSensorAvro`, `MotionSensorAvro` и др.;
* для хаба: `DeviceAddedEventAvro`, `ScenarioAddedEventAvro`, `HubEventAvro` и др.

**Технологии**:
* HTTP (Spring Boot);
* JSON (Jackson);
* Avro (сериализация);
* Kafka (брокер сообщений);
* OpenAPI (валидация).

### 2. Сервис Aggregator


**Назначение**: агрегация событий датчиков в снапшоты (снимки состояния) умного дома для последующей обработки сценариями.

**Основные задачи**:
* чтение событий из топика Kafka `telemetry.sensors.v1`;
* формирование снапшотов состояния всех датчиков конкретного хаба;
* обновление снапшотов при получении новых данных;
* запись изменённых снапшотов в топик Kafka `telemetry.snapshots.v1`.

**Ключевые компоненты**:
* **Консьюмер Kafka** — читает события датчиков из `telemetry.sensors.v1`.
* **Продюсер Kafka** — записывает обновлённые снапшоты в `telemetry.snapshots.v1`.
* **Хранилище снапшотов** — набор объектов `SensorsSnapshotAvro`, хранящий текущее состояние всех хабов.
* **Десериализатор Avro** (`BaseAvroDeserializer`) — преобразует двоичные данные из Kafka в объекты Java.
* **Схема Avro** `SensorsSnapshotAvro` — описывает структуру снапшота.

**Алгоритм работы**:
1. Получение события датчика из топика `telemetry.sensors.v1`.
2. Проверка наличия снапшота для `hubId` из события:
    * если снапшота нет — создаётся новый;
    * если есть — извлекается из хранилища.
3. Проверка наличия данных о датчике в снапшоте:
    * если данных нет — они добавляются;
    * если есть — сравниваются таймстемпы.
4. Обновление снапшота только если новое событие «свежее» (имеет больший таймстемп) и содержит новые данные.
5. Запись обновлённого снапшота в топик `telemetry.snapshots.v1` (только при изменении).
6. Фиксация смещений в Kafka.


**Условия записи в Kafka**:
* Снапшот записывается **только при изменении** его состояния.
* Если состояние не изменилось — запись не производится (дедупликация).


**Технологии**:
* Kafka (консьюмер и продюсер);
* Avro (сериализация/десериализация);
* Spring Boot (основа приложения);
* Java (реализация логики агрегации).


### 3. Сервис Analyzer


**Назначение**: анализ состояния датчиков и выполнение пользовательских сценариев.

**Основные задачи**:
* обработка снапшотов состояния хаба;
* проверка условий сценариев;
* выполнение действий через gRPC (`Hub Router`);
* обновление базы данных при изменениях в конфигурации хаба.


**Компоненты**:
* **Консьюмеры Kafka**:
    * `SnapshotProcessor` — анализ снапшотов;
    * `HubEventProcessor` — обработка событий хаба.
* **База данных** (PostgreSQL): таблицы `scenarios`, `sensors`, `conditions`, `actions` и связи между ними.
* **gRPC‑клиент** для взаимодействия с `Hub Router` (метод `handleDeviceAction`).


**Алгоритм работы**:
1. Получение снапшота и загрузка сценариев для `hubId`.
2. Проверка условий каждого сценария.
3. Формирование и отправка `DeviceActionRequest` при выполнении условий.
4. Обновление БД при событиях хаба.


**Технологии**:
* Kafka (консьюмеры);
* PostgreSQL (JPA/Hibernate);
* gRPC (взаимодействие с хабом);
* Java Stream API (обработка условий).


---


## Блок 2. Микросервисы интернет‑магазина


### 1. Сервис `shopping-store` (витрина товаров)


**Назначение**: предоставление информации о товарах и управление ассортиментом.


**Реализованная функциональность**:
* создание нового товара;
* обновление товара в ассортименте (описание, характеристики);
* получение списка товаров по типу с пагинацией;
* удаление товара из ассортимента (для менеджеров);
* получение информации о товаре из БД;
* отображение товаров по категориям (`CONTROL`, `SENSORS`, `LIGHTING`);
* детальная информация о товаре (описание, доступность, отпускная цена);
* управление товарами (добавление, редактирование, деактивация);
* отслеживание доступности (состояния: `ENDED`, `FEW`, `ENOUGH`, `MANY`);
* предоставление отпускной цены товара по идентификатору.


**Состояния товара**:
* `ACTIVE` — доступен для покупки;
* `DEACTIVATE` — скрыт из витрины (без удаления из БД).


**Интеграции**:
* `interaction-api` — использование DTO и Feign‑интерфейсов;
* `Eureka` — регистрация сервиса;
* `Spring Cloud Config` — внешние настройки.


**Технологии**:
* Spring Boot (REST API);
* Eureka (регистрация сервиса);
* Spring Cloud Config (внешние настройки);
* OpenAPI (спецификация эндпоинтов);
* PostgreSQL (хранение данных о товарах).


### 2. Сервис `shopping-cart` (корзина покупателя)


**Назначение**: управление корзиной пользователя.


**Реализованная функциональность**:
* отображение актуального состава корзины для авторизованного пользователя;
* добавление товара в корзину;
* удаление товара из корзины;
* изменение количества товаров в корзине;
* деактивация корзины для пользователя;
* проверка доступности товаров на складе (через Feign‑клиент к `warehouse`);
* сохранение ссылки на корзину для формирования заказа в сервисе `order`.


**Особенности**:
* использование имени пользователя из запроса (без авторизации);
* интеграция с `warehouse` через Feign;
* передача данных о корзине в сервис `order` при оформлении заказа.


**Интеграции**:
* `warehouse` (через Feign) — проверка наличия товаров;
* `interaction-api` — общие DTO и интерфейсы;
* `Eureka` — регистрация сервиса.


**Технологии**:
* Spring Boot (REST API);
* Feign (взаимодействие с `warehouse`);
* Eureka (регистрация сервиса);

### 3. Сервис `warehouse` (склад)


**Назначение**: управление запасами и обработка запросов от других сервисов.

**Реализованная функциональность**:
* принятие товара на склад;
* добавление нового товара на склад;
* проверка доступности товаров по корзине;
* получение адреса склада;
* хранение характеристик товаров (размеры, вес, хрупкость, адрес склада).

**Новые функции для работы с заказами**:
* `assemblyProductForOrderFromShoppingCart` — сборка заказа по продуктовой корзине (проверка наличия, уменьшение остатка, создание `OrderBooking`);
* `shippedToDelivery` — передача товаров в доставку (обновление данных о заказе, привязка идентификатора доставки);
* `returnProduct` — возврат товара на склад (увеличение остатка).


**Формат адреса**:
* страна, город, улица, дом, квартира (заполняются значением `ADDRESS_X`).

**Интеграции**:
* `shopping-cart` (через Feign) — проверка доступности;
* `order` — передача данных о сборке заказа;
* `delivery` — передача товаров в доставку;
* `interaction-api` — общие DTO и интерфейсы;
* `Eureka` — регистрация сервиса.

**Технологии**:
* Spring Boot (REST API);
* Eureka (регистрация сервиса);
* Feign (интеграция с `shopping-cart`, `order`, `delivery`);
* PostgreSQL (хранение данных о запасах).


### 4. Сервис `order` (управление заказами)


**Назначение**: обеспечение полного цикла работы с сущностью «Заказ» — от создания до доставки и возврата.

**Функции**:
* создание нового заказа на основе корзины;
* расчёт стоимости доставки (через `delivery`);
* расчёт итоговой стоимости заказа (через `payment`);
* получение списка заказов клиента;
* сборка заказа (через `warehouse`);
* отгрузка товаров (через `delivery`);
* обработка ошибок (оплата, сборка, доставка);
* оформление возврата заказа.

**Состояния заказа**:
* `NEW` — новый;
* `ON_PAYMENT` — ожидает оплаты;
* `ON_DELIVERY` — ожидает доставки;
* `DONE` — выполнен;
* `DELIVERED` — доставлен;
* `ASSEMBLED` — собран;
* `PAID` — оплачен;
* `COMPLETED` — завершён;
* `DELIVERY_FAILED` — неудачная доставка;
* `ASSEMBLY_FAILED` — неудачная сборка;
* `PAYMENT_FAILED` — неудачная оплата;
* `PRODUCT_RETURNED` — возврат товаров;
* `CANCELED` — отменён.

**Данные заказа**:
* список товаров с количеством;
* ссылка на корзину;
* ссылка на доставку;
* ссылка на оплату;
* объём и вес товаров;
* признак хрупкости;
* итоговая цена;
* цена товаров;
* цена доставки.

**Интеграции**:
* `shopping-cart` — получение данных корзины;
* `warehouse` — сборка заказа;
* `delivery` — управление доставкой;
* `payment` — обработка оплаты;
* `interaction-api` — общие DTO и интерфейсы;
* `Eureka` — регистрация сервиса.

**Технологии**:
* Spring Boot (REST API);
* Eureka (регистрация сервиса);
* Feign (взаимодействие с другими сервисами);
* PostgreSQL (хранение данных о заказах).

**Feign‑клиенты для `order`**:
* `delivery`:
    * `planDelivery` — создание доставки;
    * `deliveryCost` — расчёт стоимости доставки при общем расчёте стоимости.
* `payment`:
    * `productCost` — расчёт стоимости товаров;
    * `getTotalCost` — расчёт общей стоимости товаров, доставки и налога;
    * `payment` — запуск процесса оплаты.
* `warehouse`:
    * `assemblyProductForOrderFromShoppingCart` — сборка заказа по продуктовой корзине;
    * `getWarehouseAddress` — формирование адреса «Откуда» для расчёта и сохранения «Доставки».

### 5. Сервис `payment` (эмулятор платёжного шлюза)

**Назначение**: эмуляция платёжного шлюза для расчёта и обработки платежей.

**Функции**:
* расчёт стоимости товаров в заказе (умножение количества на отпускную цену);
* расчёт итоговой стоимости заказа (товары + доставка + НДС 10 %);
* сохранение данных об оплате в БД;
* обновление статуса оплаты (`PENDING`, `SUCCESS`, `FAILED`);
* уведомление сервиса `order` об изменении статуса.

**Алгоритм расчёта итоговой стоимости**:
1. Суммирование стоимости всех товаров в заказе.
2. Расчёт НДС: $10\%$ от суммы товаров.
3. Добавление стоимости доставки.
4. Итоговая сумма: $\text{товары} + \text{НДС} + \text{доставка}$.

**Пример расчёта**:
* стоимость товаров: 100 руб.;
* НДС ($10\%$): $100 \cdot 0{,}1 = 10$ руб.;
* доставка: 50 руб.;
* итого: $100 + 10 + 50 = 160$ руб.

**Данные об оплате**:
* стоимость товаров;
* стоимость доставки;
* общая стоимость;
* статус оплаты.

**Статусы оплаты**:
* `PENDING` — ожидает оплаты;
* `SUCCESS` — успешно оплачен;
* `FAILED` — ошибка в процессе оплаты.

**Интеграции**:
* `order` — получение данных заказа, уведомление об изменении статуса оплаты;
* `delivery` — расчёт стоимости доставки;
* `shopping-store` — получение отпускной цены товара;
* `interaction-api` — общие DTO и интерфейсы;
* `Eureka` — регистрация сервиса.

**Технологии**:
* Spring Boot (REST API);
* Eureka (регистрация сервиса);
* Feign (взаимодействие с другими сервисами);
* PostgreSQL (хранение данных об оплатах).

**Feign‑клиенты для `payment`**:
* `order`:
    * `paymentFailed` — обновление статуса заказа при неудачной оплате;
    * `paymentSuccess` — обновление статуса заказа при успешной оплате.
* `shopping-store`:
    * `getProduct` — получение сведений о товаре по идентификатору.

### 6. Сервис `delivery` (управление доставкой)

**Назначение**: эмуляция сервиса доставки для расчёта и управления доставкой заказов.

**Функции**:
* сохранение данных о доставке в БД и возврат идентификатора доставки;
* расчёт стоимости доставки (с учётом адреса склада, веса, объёма, хрупкости);
* принятие товаров в доставку (изменение статуса на `IN_PROGRESS`);
* обновление статуса доставки (`DELIVERED`, `FAILED`, `CANCELLED`);
* уведомление сервиса `order` об изменении статуса.

**Данные доставки**:
* объём и вес товаров;
* признак хрупкости;
* адрес «Откуда» и «Куда» (структура: страна, город, улица, дом, квартира);
* статус доставки:
    * `CREATED` — создана;
    * `IN_PROGRESS` — в процессе;
    * `DELIVERED` — доставлена;
    * `FAILED` — ошибка;
    * `CANCELLED` — отменена;
* ссылка на заказ (идентификатор).

**Алгоритм расчёта стоимости доставки**:
1. Базовая стоимость: $5{,}0$ руб.
2. Умножение на коэффициент склада:
    * `ADDRESS_1` → ×1;
    * `ADDRESS_2` → ×2.
3. Если товар хрупкий: добавление $20\%$ от текущей суммы.
4. Добавление стоимости за вес: $0{,}3 \cdot \text{вес}$ кг.
5. Добавление стоимости за объём: $0{,}2 \cdot \text{объём}$ м³.
6. Если адрес доставки не совпадает с адресом склада: добавление $20\%$ от текущей суммы.

**Пример расчёта**:
* адрес склада: `ADDRESS_2` (коэффициент 2);
* вес: 10 кг;
* объём: 10 м³;
* хрупкий товар: да;
* улица доставки не совпадает со складом.

Расчёт:
1. $5 \cdot 2 = 10$;
2. $10 + 5 = 15$ (базовая + коэффициент);
3. $15 \cdot 0{,}2 = 3$ (за хрупкость); $15 + 3 = 18$;
4. $18 + (10 \cdot 0{,}3) = 21$ (за вес);
5. $21 + (10 \cdot 0{,}2) = 23$ (за объём);
6. $23 \cdot 0{,}2 = 4{,}6$ (за несовпадение адреса); $23 + 4{,}6 = 27{,}6$ руб.

**Интеграции**:
* `order` — обновление статуса заказа при изменении статуса доставки;
* `warehouse` — передача товаров в доставку;
* `interaction-api` — общие DTO и интерфейсы;
* `Eureka` — регистрация сервиса.

**Технологии**:
* Spring Boot (REST API);
* Eureka (регистрация сервиса);
* Feign (взаимодействие с другими сервисами);
* PostgreSQL (хранение данных о доставке).

**Feign‑клиенты для `delivery`**:
* `order`:
    * `deliveryFailed` — обновление статуса заказа при неудачной доставке;
    * `delivery` — обновление статуса заказа при успешной доставке.
* `warehouse`:
    * `shippedToDelivery` — передача товаров в службу доставки.

### 7. Модуль `interaction-api`

**Назначение**: централизованное хранение DTO и Feign‑интерфейсов для межсервисного взаимодействия.

**Содержание**:
* DTO‑объекты для обмена данными (товары, корзина, заказ, оплата, доставка);
* Feign‑интерфейсы сервисов (`shopping-store`, `shopping-cart`, `warehouse`, `order`, `payment`, `delivery`).

**Технологии**:
* Java (классы DTO);
* Spring Cloud OpenFeign (интерфейсы).

### 8. Модуль `api-gateway`

**Назначение**: единая точка входа для всех клиентов приложения.

**Задачи**:
* добавление роутов для новых сервисов (`order`, `payment`, `delivery`);
* обеспечение балансировки нагрузки (Load Balancer) между экземплярами сервисов;
* предоставление унифицированного доступа к микросервисам через единый эндпоинт.

**Требования к конфигурации**:
1. Каждый новый роут должен добавлять префикс `/api/v1` к пути запроса.
2. Запросы должны переадресовываться к соответствующему микросервису.
3. Обязательно использование Load Balancer для балансировки запросов.
4. Настройки роутов размещаются в конфигурационном файле Gateway‑сервиса (в модуле сервера конфигураций).

**Технологии**:
* Spring Cloud Gateway (основная функциональность);
* Eureka (для обнаружения сервисов и балансировки);
* Spring Cloud Config (внешняя конфигурация).

**Проверка работоспособности**:
1. Запуск всех сервисов приложения.
2. Выполнение тестовых запросов через Gateway (например, `http://localhost:8080/api/v1/delivery/cost`).
3. Проверка корректности маршрутизации и обработки запроса целевым сервисом.
4. Запуск двух экземпляров сервиса `delivery` и проверка балансировки запросов между ними.

---

## Общая архитектура и интеграции


### Паттерны проектирования
1. **Database per Service** — каждый микросервис имеет собственную БД.
2. **Externalized Configuration** — настройки через Spring Cloud Config.
3. **Service Discovery** — регистрация сервисов в Eureka.
4. **API Gateway** — единая точка входа через Spring Cloud Gateway.

### Межсервисное взаимодействие
* **Протокол**: REST через Feign‑клиенты.
* **Обмен данными**: DTO‑объекты из модуля `interaction-api`.
* **Обнаружение сервисов**: Eureka.
* **Балансировка**: Load Balancer (встроен в Spring Cloud Gateway).

### Ключевые технологии
* **Spring Boot** — основа всех микросервисов.
* **Spring Cloud** (Config, Eureka, Gateway) — инфраструктура.
* **Feign** — клиент для межсервисных вызовов.
* **Kafka** — брокер сообщений (для телеметрии).
* **PostgreSQL** — СУБД для хранения данных.
* **gRPC** — взаимодействие с хабом умного дома.
* **Avro** — сериализация данных для Kafka.
* **Lombok** — упрощение кода Java.
* **Jackson** — работа с JSON.

### Настройки Eureka
* Порт по умолчанию: `8761`.
* Имена сервисов для регистрации:
    * `shopping-store`;
    * `shopping-cart`;
    * `warehouse`;
    * `order`;
    * `payment`;
    * `delivery`.

### Структура модулей
1. **`telemetry`** — код для работы с устройствами умного дома.
2. **`commerce`** — код интернет‑магазина, включает подмодули:
    * `shopping-store`;
    * `shopping-cart`;
    * `warehouse`;
    * `order`;
    * `payment`;
    * `delivery`.
3. **`interaction-api`** — общие DTO и Feign‑интерфейсы.
4. **`api-gateway`** — шлюз для маршрутизации запросов.